# 递归函数
在一个函数中调用函数自身的行为叫做递归
递归函数必须要有停止条件

一个经典的递归函数是计算斐波那契数列
```cpp
#include <iostream>
using namespace std;
int fib(int n)
{
	if (n <= 1) return n;
	else return fib(n - 1) + fib(n - 2);
}
int main()
{
	
}
```
会发现这样的写法虽然有效，但是重复计算了很多次。
如当 n=5 时，`fib(1)` 会被调用 4 次，但实际上每次调用的结果都会是 1
由此可以引出一个优化方法，利用数组记录计算过的结果，如下例：
```cpp
int memo[MAX_N + 1];

int fib(int n)
{
	if (n <= 1) return n;
	if (memo[n] != 0) return memo[n];
	return memo[n] = fib(n - 1) + fib(n - 2); 
}
```
这种思想来自于动态规划和记忆化搜索
# 栈
栈是一种先进后出的数据结构，有 push 和 pop 两种操作
实践中一般使用 C++ 标准库中的 stack
用法如下例：
```cpp
#include <stack>
#include <iostream>

using namespace std;
int main()
{
	stack<int> s;
	s.push(1); //往栈中压入元素1 {}->{1}
	s.push(2); //往栈中压入元素2 {1}->{1, 2}
	s.push(3); //往栈中压入元素3 {1, 2}->{1, 2, 3}
	cout<<s.top()<<endl; //输出栈顶元素3
	s.pop(); //弹出栈顶元素3 {1, 2, 3}->{1, 2}
	cout<<s.top()<<endl; //输出栈顶元素2
	s.pop(); //同上，略
	cout<<s.top()<<endl;
	s.pop();
	return 0;
}
```
# 队列
先进先出的数据结构，与 stack 类似，支持 push 和 pop 两种操作
实践中使用 C++标准库中的 stack，用例如下
```cpp
#include <queue>
#include <iostream>

using namespace std;
int main()
{
	queue<int> s;
	s.push(1); //往队列中压入元素1 {}->{1}
	s.push(2); //往队列中压入元素2 {1}->{1, 2}
	s.push(3); //往队列中压入元素3 {1, 2}->{1, 2, 3}
	cout<<s.front()<<endl; //输出队列底元素1
	s.pop(); //弹出队列底元素1 {1, 2, 3}->{2, 3}
	cout<<s.front()<<endl; //输出队列底元素2
	s.pop(); //同上，略
	cout<<s.front()<<endl;
	s.pop();
	return 0;
}
```
# 深度优先搜索
从某个状态开始，不断地转移状态直到无法转移，再回退继续尝试别的状态直到找到最终的解
例题：给定一堆整数，判断是否可以从中选出若干数使之和恰好为 k
```cpp
#include <iostream>
#define MAXNUM 21

using namespace std;
int N,k;
int num[MAXNUM];
bool dfs(int n, int sum)
{
    if (sum + num[n] == k) return true;
    if (dfs(n + 1, sum)) return true;
    if (dfs(n + 1, sum += num[n])) return true;
    return false;
}
void solve()
{
    if (dfs(0, 0)) cout<<"Yes"<<endl;
    else cout<<"No"<<endl;
}
int main()
{
    cin>>N;
    for(int i = 0; i < N; i++)
    {
        cin>>num[i];
    }
    cin>>k;
    solve();
}
```

例题：[2386 -- Lake Counting](http://poj.org/problem?id=2386)
```cpp
#include <iostream>
#define MAX_N 110
using namespace std;

int N, M;
char map[MAX_N][MAX_N];
void dfs(int i, int j)
{
    map[i][j] = '.';
    for (int dx = -1; dx <= 1; dx++)
    {
        for (int dy = -1; dy <= 1; dy++)
        {
            int nx = i + dx;
            int ny = j + dy;
            if (nx > 0 && ny > 0 && nx <= N && ny <= M && map[nx][ny] == 'W') dfs(nx, ny);
        }
    }
    return;
}
int main()
{
    cin>>N>>M;
    int res = 0;
    for (int i = 1; i <= N; i++)
    {
        for (int j = 1; j <= M; j++)
        {
            cin>>map[i][j];
        }
    }
    for (int i = 1; i <= N; i++)
    {
        for (int j = 1; j <= M; j++)
        {
            if (map[i][j] == 'W')
            {
                dfs(i, j);
                res++;
            }
        }
    }
    cout<<res<<endl;
    return 0;

}
```
思路是我们可以通过 DFS 遍历一整个水塘，然后将其清理为干地
每次 DFS 都会找到并清理一个水塘
我们最后 DFS 的次数就会是水塘的数量

# 宽度优先搜索
不同于 DFS，BFS 会先探索距离初始状态近的状态
开始状态 -> 1 次转移到达的状态 -> 2 次转移到达的状态 -> ......
深度优先搜索隐式地利用了栈（递归）进行计算，宽度优先搜索利用了队列：
先将初始状态加入队列，然后从队列最前端取出状态，将所取出的状态可以转移的状态加入队列，如此往复
例题：迷宫的最短路径
> 给定一个 $N\times M$ 的迷宫，迷宫由墙壁和通道组成，每一步可以向邻接的上下左右四格的通道移动。请求出从起点到终点所需的最小步数。本题假定一定可以到终点
> $N,M\leq 100$

```cpp
#include <iostream>
#include <queue>
const int INF = 0x7ffffff;
const int MAXNUM = 110;
using namespace std;

typedef pair<int, int> P;
char maze[MAXNUM][MAXNUM];
int dis[MAXNUM][MAXNUM];
int sx,sy;
int gx,gy;
int N,M;
int dx[4] = {-1, 0, 1, 0};
int dy[4] = {0, -1, 0, 1};
int bfs()
{
    queue<P> que;
    dis[sx][sy] = 0;
    que.push(P(sx, sy));
    while(que.size())
    {
        P p = que.front(); que.pop();
        if (p.first == gx && p.second == gy) break;
        for (int i = 0; i < 4; i++)
        {
            int nx = p.first + dx[i];
            int ny = p.second + dy[i];
            if (nx > 0 && ny > 0 && nx <= N && ny <= M && maze[nx][ny] != '#' && dis[nx][ny] == INF)
            {
                que.push(P(nx, ny));
                dis[nx][ny] = dis[p.first][p.second] + 1;
            }
        }
    }
    return dis[gx][gy];
}
int main()
{
    cin>>N>>M;
    for (int i = 1; i <= N; i++)
    {
        for (int j = 1; j <= M; j++)
        {
            dis[i][j] = INF;
            cin>>maze[i][j];
            if (maze[i][j] == 'S')
            {
                sx = i;
                sy = j;
            }
            if (maze[i][j] == 'G')
            {
                gx = i;
                gy = j;
            }
        }
    }
    cout<<bfs()<<endl;
	return 0;
}
```
可以留意代码中 pair 的用法
```cpp
typedef pair<int, int> P;
//通过typedef创建P这个类型
queue<P> que;
//创建元素为P类型的队列
que.push(P(sx, sy));
//这里P()将sx和sy绑定成一对，压进队列里
P p = que.front(); que.pop();

if (p == P(gx, gy)) break;
if (p == make_pair(gx, gy)) break;
if (p.front == gx && p.second == gy) break;
//以上三种写法是等价的
//make_pair、P将gx，gy绑定在一起成为一个pair，以此来和p对比是否相等

```
要注意实现的时候我们将没有访问过的路径设置为 INF，但有的时候 INF 不是作为一种例外，而会直接参与普通运算，譬如当 INF 设置为 $2^{31}-1$ 时
通过 `d[nx][ny]=min(d[nx][ny], d[x][y]+1)` 来更新 `d[nx][ny]` 会导致 INF+1= $-2^{31}$ 的情况
所以一般 INF 会设置为放大 2~4 倍也不会溢出的大小

# 特殊状态的枚举
在状态空间特殊时，有时会有一些神秘解法
譬如 C++标准库提供的 `next_permutation` 函数会生成 n 个元素共 $n!$ 种不同的排列
具体用法可参
```cpp
#include <iostream>
#include<algorithm>
using namespace std;
 
int main(int argc, char** argv) {
	int a[4]={1,2,3,4};
	sort(a,a+4);
	do{
		//cout<<a[0]<<" "<<a[1]<<" "<<a[2]<<" "<<a[3]<<endl;
		for(int i=0;i<4;i++)
		    cout<<a[i]<<" ";
		cout<<endl;
	}while(next_permutation(a,a+4));
	return 0;
}
```
当不存在"下一个"排列组合时，函数会返回 false，其他情况会对所给范围的元素进行排列。其生成的排列是按字典序排列的，所以有固定的第一个和最后一个。
# 剪枝
此处简述：深度优先搜索时，有时候早就明确当前状态如何转移都不会存在解，这种情况就可以直接跳过了，这样的操作称为剪枝。
在前文的部分和问题中，当状态大于 k 时就可以跳过