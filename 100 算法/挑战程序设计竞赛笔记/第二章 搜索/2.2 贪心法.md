贪心法就是遵循某种规则，不断贪心地选取当前最优策略的设计方法 
#  硬币问题
贴近生活的简单问题，凭直觉会认为优先多选面额高的钱币即可
```cpp
#include <iostream>
using namespace std;
const int V[6] = {1, 5, 10, 50, 100, 500};
int C[6];
int k;
int main()
{
    for (int i = 0; i < 6; i++)
    {
        cin>>C[i];
    }
    cin>>k;
    int num = 0;
    for (int i = 5; i >= 0; i--)
    {
        num += min(k / V[i], C[i]);
        k -= V[i] * min(k / V[i], C[i]);
    }
    cout<<num;
    return 0;
}
```
# 区间问题
思考如下问题：
> 有 n 项工作，每项工作分别在 $s_{i}$ 时间开始，在 $t_{i}$ 时间结束。对于每项工作，可以选择参加与否。参加工作的时间段不能重叠，问最多参加多少项工作

用贪心算法解答这道题，需要确立一个正确的规则。我们可以想到很多思路：
- 每次选开始时间最早的工作
- 每次选用时最短的工作
- 每次选与最少可选工作重叠的工作
但上述都是错的，能举出反例
正确的思路是：每次选取结束时间最早的工作
```cpp
#include <iostream>
#include <algorithm>
const int MAX_N = 100010;
using namespace std;
pair<int, int> jobs[MAX_N];
int T[MAX_N], S[MAX_N];
int n;
int Solve()
{
    for (int i = 0; i < n; i++)
    {
        jobs[i].first = T[i];
        jobs[i].second = S[i];
    }
    sort(jobs, jobs + n);
    int ans = 0; int t = 0;
    for (int i = 0; i < n; i++)
    {
        if (t < jobs[i].second)
        {
            t = jobs[i].first;
            ans++;
        }
    }
    return ans;
}
int main()
{
    cin>>n;
    for (int i = 0; i < n; i++)
    {
        cin>>S[i];
    }
    for (int i = 0; i < n; i++)
    {
        cin>>T[i];
    }
    cout<<Solve()<<endl;
    return 0;
}
```

> 贪心算法的证明

# 字典序最小问题
给定长度为 N 的字符串 S，要构造一个长度为 N 的字符串 T。起初 T 是一个空串，随后反复进行下列任意操作：
- 从 S 的头部删除一个字符，加到 T 的尾部
- 从 S 的尾部删除一个字符，加到 T 的尾部
目标是构造字典序尽可能小的字符串 T

```cpp
#include <iostream>
using namespace std;
const int MAX_N = 2010;
int N;
char S[MAX_N],T[MAX_N];
int main()
{
    cin>>N;
    for (int i = 0; i < N; i++)
    {
        cin>>S[i];
    }
    int arr_front = 0;
    int arr_back = N - 1;
    while (arr_front <= arr_back)
    {
        bool front = false;
        for (int i = 0; arr_front + i <= arr_back; i++)
        {
            if (S[arr_front + i] < S[arr_back - i])
            {
                front = true;
                break;
            }
            else if (S[arr_back - i] <S[arr_front] +i)
            {
                front =false;
                break;
            }
        }
        if (front) putchar(S[arr_front++]);
        else putchar(S[arr_back--]);
    }
}
```

可以留意其中
```cpp
if (front) putchar(S[arr_front++]);
else putchar(S[arr_back--]);
//这里a++用法是先输出再自增
//a--则是先输出再自减
//--a、++a是先运算再输出
```

# Saruman's Army
> 直线上有 N 个点。点 i 的位置是 $X_{i}$ 。从这 N 个点中选择若干个，给它们加上标记。对每一个点，其距离为 R 以内的区域里必须有带有标记的点、
> （自己本身带有标记的点，可以认为与其距离为 0 的地方有一个带有标记的点）。在满足这个条件的情况下，希望能为尽可能少的点添加标记。请问至少要有多少点被加上标记

思路：从最左边的点开始，找到能覆盖最左边的点的最远的点，上一个标记。随后将下一个没有被覆盖的点视为最左边的点，继续该流程，直到所有点被遍历一次
```cpp
#include <iostream>
#include <algorithm>
const int MAX_N = 1010;
using namespace std;
int N,R;
int ans = 0;
int X[1010];
int main()
{
    cin>>N;
    cin>>R;
    for (int i = 0; i < N; i++)
    {
        cin>>X[i];
    }
    sort(X, X + N);
    int left;
    int i = 0;
    while (i < N)
    {
        left = X[i];
        while (i < N && left + R >= X[i]) i++;
        int P = X[i - 1];
        while (i < N && X[i] <= P + R) i++;
        ans++;
    }
    cout<<ans<<endl;
}
```
# Fence Repair
