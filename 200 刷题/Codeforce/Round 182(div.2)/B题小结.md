总的来说我们的思路是分情况讨论

一般地，我们关注“不在其本该在的位置的数字”
即 a[j] != j 
为了使需要操作的子段最长，我就想找到
符合上述条件的最左边的数和最右边的数
于是分别用一个指针指向找到的符合条件的左右区间端点

但有时候会出现存在0的情况，这里我们分两种情况讨论

0的数量多于1
这意味着我们可以把 a[j] == 0 是做是一种 a[j] != j
然后回到上面的逻辑
因为多余1个0就意味着我可以手动操控0所在位置的数，使之不在其本该在的位置

0的数量等于1
这时候我们知道0位置的数其实是确定的
- 如果左右指针都指向这个0，说明这个序列是排列好的
- 如果左右指针有一个指向这个0，则需进一步判断

我们找到那个数，然后再看他是不是 a[j] != j，以此确定我们的指针是否有效

如果有效，那么按原本的逻辑计算
如果无效
我们引入一对指向“不在其本该在位置且非0”的数的指针
此时采用这对指针进行计算即可

