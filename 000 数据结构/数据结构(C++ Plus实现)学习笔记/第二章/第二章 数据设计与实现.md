# ADT
ADT：抽象数据类别
ADT包含以下四类基本操作
- 构造函数
- 转换函数
- 观察者函数
- 迭代器
本书介绍概念的顺序是从
- 逻辑层（抽象视图）
- 应用层（可以解决什么问题）
- 实现层
三个方面入手

首先介绍了结构体（记录）
# 结构体
## 逻辑层
有限集合组成的复合数据类型
> **传递参数**
> 分为值参数和引用参数，前者会在函数里创建一个实参数的副本，操作不影响实参数的值；后者会传递实参数的地址，操作会影响实参数的值。
> C++中若要指定非数组参数为引用参数，需在形参列表的类型名称右侧附加一个 & 符号
> 数组默认通过引用传递
## 应用层
处理具有许多特征的建模对象——以单个名称引用整个对象，通过名称引用对象的不同成员
## 实现层
基地址+偏移以访问成员位置
结构化与非结构化：结构化就是与顺序相关，非结构化就是与顺序无关
> 一个例子是结构体在实现上是结构化的（系统申请一段连续的内存空间，且按照声明变量的序存储数据），但在使用上是非结构化的（用户通过变量名访问，而非位置）
# 一维数组
## 逻辑层
结构化的复合数据类型，有限的固定大小的有序同类元素组成
>C++中数组只能作为引用参数
>声明一维数组参数时，编译器只需要知道这是一个数组，不需要知道其大小。因此经常向函数传递一个单独的参数以指定将处理多少个数组插槽
>而若始终将数组作为引用参数传递，则可将其声明为const参数，如
```Cpp
int SumValues (const int values[], int numberOfValues)
```
## 应用层
杂货铺清单、电话号码表、字符串等
## 实现层
略
# 二维数组
## 逻辑层
由有限的、固定大小的、按二维顺序排列的同类型元素组成
> C++中，二维参数的以行的顺序进行存储：一行中所有的元素都存储在一起，然后是下一行中的所有元素。
> 为了访问第一行以外的任意以行，编译器需要能计算每一行的开始地址，这需要知道每行中有多少元素。
> 因此，二维数组的形式参数的声明需要包含第二个维度的大小，例如
```cpp
int ProcessValues(int values[][5]
```
## 应用层
通常将地图表示为二维数组
## 实现层
书本也略了
# 高级抽象和C++类
类是构造类型，其中类的既可以是函数也可以是数据。这意味着类是将数据成员以及相关的操作绑定在一起的集合体。
>数据是和对象绑定在一起的，所以可以使用一个对象来构建另一个对象：一个对象的数据成员可以是另一个对象

类的定义体现了ADT的思想：设计ADT时希望将数据类型的操作和正在处理的数据绑定在一起。类强制执行封装。
类的作用就像手表的外壳，阻止我们直接摆弄其内部的零件。

类分为说明和实现两部分
## 类的规格说明
```cpp
//以下是 DateType.h 的内容，需要注意类的说明会存在 .h 文件中
class DateType
{
public:
	void Initialize(int newMonth, int newDay, int newYear);
	int GetYear() const;
	int GetMonth() const;
	int GetDay() const;
private:
	int year;
	int month;
	int day;
};
```
其中
- 类的数据成员是year、month和year
- 类的作用域包含成员函数的参数，所以必须使用数据成员名以外的名称作为形参
- 数据成员被标记为private，意味着客户端代码不能访问他们（即使用这个类时候不能访问）
- 那几个成员函数被标记为public，客户代码可以访问这些函数
- 访问函数（Get打头那几个）旁边的const保证这些函数不会改变访问对象的任何数据成员
## 类的实现
```cpp
//以下是 DateType.cpp 文件的内容
#include “DateType.h”

void DateType::Initialize(int newMonth, int newDay, int newYear)
{
	year = newYear;
	month = newMonth;
	day = newDay;
}

int DateType::GetMonth() const
{
	return month;
}

int DateType::GetYear() const
{
	return year;
}

int DateType::GetDay() const
{
	return day;
}
```
要使用 DateType 类的客户端必须包含 `#include “DateType.h”` ，之后客户端就可以声明类型为 DateType 的变量，以及调用类的成员函数，如以下代码所示
```cpp
#include “DateType.h”
DateType today;
DateType anotherDay;
today.Initialize(9, 24, 2003);
anotherDay.Initialize(9, 25, 2003);
count <<“Today is” << today.GetMonth() <<“/” << today.GetDay()
	  <<“/“ << today.GetYear() << endl;
```
## 带对象参数的成员函数
[enum教程](https://www.runoob.com/w3cnote/cpp-enums-intro-and-strongly-typed.html)
```cpp
//enum枚举类型的实例，详情可参菜鸟教程
#include<iostream>
using namespace std;
int main()
{
	enum enumType {one=1 ,two ,three=1 ,four ,five} number;
	number=three;
	cout<<number<<endl;
	enumType number2=number;
	if(number2==one&&number2==three) cout<<1<<endl;
}
```
本节内容介绍了在一个类的成员函数想要操作多个类成员的实现方法，代码比较易懂，可参
```cpp
//以下内容是规格说明文件 DateType.h 的补充
enum RelationType {LESS, EQUAL, GREATER}
RelationType ComparedTo(DateType someDate); //将自身（self）与 someDate 比较
```
下为实现方法
```cpp
RelationType DateType::ComparedTo(DateType aDate)
{
	if(year < aDate.year)
		return LESS;
	else if(year > aDate.year)
		return GREATER;
	else if(month < aDate.month)
		return LESS;
	else if(month > aDate.month)
		return GREATER;
	else if(day < aDate.day)
		return LESS;
	else if(day > aDate.day)
		return GREATER;
	else return EQUAL;
}
```

客户端代码中，这个比较函数则是这样使用的:
```cpp
 switch(today.ComparedTo(anotherDay))
 {
	 case LESS :
		 cout <<“today comes before anotherDay”;
		 break;
	 case GREATER :
		 cout <<”today comes after anotherDay”;
	 case EQUAL :
		 cout <<“today and anotherDay are the same”; 
 }
```
## 类和结构的区别
在不使用 public 和 private 的情况下，成员函数和数据在类中默认是私有的，在结构中默认是公共的
而在实践中，结构和类会以不同的方式使用。
# 面向对象的程序设计
概念：
- 对象是类对象或者类实例。
- 方法是公共成员函数
- 实例变量是私有数据成员
任何面向对象的语言都包含三个基本成分：
- 封装
- 继承：是一种可用于构建类的层次结构的机制
	可以从一个现有的类（称为基类）创建一个新的类（派生类）
- 多态性：可以确定（在类层次结构里）应该使用多个具有相同名称的方法中的哪种方法。[重载](https://www.runoob.com/cplusplus/cpp-overloading.html)意味着给不同的函数赋予相同的名称（通过形参数量、定义的不同区分），也可以给不同的操作使用相同的运算符号
## 面向对象的C++构造
类与类的关系主要有：彼此独立、组合、继承三种
1. 组合是指类中的数据成员是另一个类的对象。只需要将一个类的数据成员声明为另一个类达到1类型即可，例如：
```cpp
#include <string>
class PersonType
{
public:
	void Initialize(string, DateType);
	string GetName() const;
	DateType GetBirthdate() const;
private:
	string name;
	DateType birthdate; 
};
```
2. 从一个类中派生出另一类（继承）
```cpp
class StudentType : public PersonType
{
public:
	string GetStatus() const;
	void Initialize(string, DateType, string);
private:
	string status;
};

StudentType student;
```
这里 PersonType 作为基类，从其派生 StudentType 类以及附加字段 status、
对声明的 StudentType 的 student：
- 有三个成员变量：一个自己的 status ，两个从 PersonType 中继承的 name 和 birthdate
- 有五个成员函数：两个自己的 Initialize 和 GetStatus ，三个从 PersonType 中继承的
要注意 student 虽然从基类继承了私有成员变量，但也并不能直接访问，必须使用 PersonType 的公共成员函数来访问其继承的成员变量。详见下例：
```cpp
void StudentType::Initialize
  (string newName, DateType newBirthdate, string newStatus)
{
	status = newStatus;
	PersonType::Initialize(newName, newBirthdate);
}

string StudentType::GetStatus() const
{
	return status;
}
```
## 虚方法
>定义一个函数为虚函数，不代表函数为不被实现的函数。
>定义他为虚函数是为了允许用基类的指针来调用子类的这个函数。
>定义一个函数为纯虚函数，才代表函数没有被实现。
>定义纯虚函数是为了实现一个接口，起到一个规范的作用，规范继承这个类的程序员必须实现这个函数。
>来自[菜鸟教程](https://www.runoob.com/w3cnote/cpp-virtual-functions.html)

在基类中实现纯虚函数的方法是在函数后添加`=0`
```cpp
virtual void function1()=0;
```
# 命名空间
不同的程序员可能会使用同样的标识符，为了避免名称冲突，C++有命名空间机制
使用`namespace`声明命名空间，在包含该空间所有名称的块声明之前进行声明。如下例：
```cpp
#include <iostream>
using namespace std;
// 第一个命名空间
namespace first_space{
   void func(){
      cout << "Inside first_space" << endl;
   }
}
// 第二个命名空间
namespace second_space{
   void func(){
      cout << "Inside second_space" << endl;
   }
}
int main ()
{
   // 调用第一个命名空间中的函数
   first_space::func();
   // 调用第二个命名空间中的函数
   second_space::func(); 
   return 0;
}
```
例子来自[C++命名空间](https://www.runoob.com/cplusplus/cpp-namespaces.html)，这里还介绍了不连续的命名空间以及嵌套命名空间

